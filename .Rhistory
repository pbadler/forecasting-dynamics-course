print(total)
}
rm(list=ls())
for(i in 2:5){
total=total + i
print(total)
}
total=10
for(i in 2:5){
total=total + i
print(total)
}
rm(list=ls())
total=10
for(i in 2:5){
total=total + i
print(total)
}
N=rep(0,10)
N[1]=1
N
for(i in 2:5){
N[i]=N[i-1]+1
}
N
500+15*5.5
rm(list = ls())
library(lme4)
#library(rjags)
library(ggplot2)
library(MASS)
####
#### Gompertz analysis for sagebrush cover
####
# setwd('~/Desktop/PermanentPlotSagebrushCoverData/GompertzAnalysis/')
#
# coverWideP = read.csv('../CleanedData/coverPptWide.csv')
# coverWideT = read.csv('../CleanedData/coverTempWide.csv')
head(coverWideP)
head(coverWideT)
coverWide = merge(coverWideP, coverWideT[ , -c(4:10)], all.y = TRUE)
####
####
spec = 'ARTRW8'
##### temp parameters
season = 'spring'
normalv = paste( 'normal.', season, sep = '')
diffv = paste ( 'seasonalDiff.', season, sep = '')
tp = 'tmin'
###### ppt parameters
season2 = 'cold'
normalv2 = paste('normal.', season2, sep = '')
diffv2 = paste( 'seasonalDiff.', season2, sep = '')
head(coverWide)
coverWide = subset(coverWide, spp == spec & type == tp & dataset != 'Passey')
summary(coverWide$cover)
hist( coverWide$cover )
summary(coverWide$cover)
hist(log(coverWide$cover))
coverWide$logCover <- log(coverWide$cover)
coverWide$logLstCover <- log(coverWide$lstCover)
coverWide = coverWide[ which( !is.na(coverWide[, diffv])), ]
coverWide$normal1 =  coverWide[, normalv]
coverWide$normal2 = coverWide[, normalv2]
#coverWide$normal = ( coverWide[ , normalv] - mean( coverWide [ , normalv], na.rm = TRUE) )
coverWide$diff1 = coverWide[, diffv]
coverWide$diff2 = coverWide[, diffv2]
ggplot(coverWide, aes(x = logLstCover, y = logCover, group = UPlotID)) +
geom_point() + geom_abline( yintercept = 0, slope =1) +
geom_smooth(se = FALSE, method = 'lm')
m1 = lmer( logCover ~ logLstCover + normal2*diff2 + (1+logLstCover|UPlotID), data = coverWide )
m1 = lmer( logCover ~ logLstCover + normal1*diff1 + (1+logLstCover|UPlotID), data = coverWide )
load("C:/Users/adler/Dropbox/ToDo/precipTempWorkspace.RData")
rm(list = ls())
library(lme4)
#library(rjags)
library(ggplot2)
library(MASS)
####
#### Gompertz analysis for sagebrush cover
####
# setwd('~/Desktop/PermanentPlotSagebrushCoverData/GompertzAnalysis/')
#
# coverWideP = read.csv('../CleanedData/coverPptWide.csv')
# coverWideT = read.csv('../CleanedData/coverTempWide.csv')
head(coverWideP)
head(coverWideT)
coverWide = merge(coverWideP, coverWideT[ , -c(4:10)], all.y = TRUE)
####
####
spec = 'ARTRW8'
##### temp parameters
season = 'spring'
normalv = paste( 'normal.', season, sep = '')
diffv = paste ( 'seasonalDiff.', season, sep = '')
tp = 'tmin'
###### ppt parameters
season2 = 'cold'
normalv2 = paste('normal.', season2, sep = '')
diffv2 = paste( 'seasonalDiff.', season2, sep = '')
head(coverWide)
coverWide = subset(coverWide, spp == spec & type == tp & dataset != 'Passey')
summary(coverWide$cover)
hist( coverWide$cover )
summary(coverWide$cover)
hist(log(coverWide$cover))
coverWide$logCover <- log(coverWide$cover)
coverWide$logLstCover <- log(coverWide$lstCover)
coverWide = coverWide[ which( !is.na(coverWide[, diffv])), ]
coverWide$normal1 =  coverWide[, normalv]
coverWide$normal2 = coverWide[, normalv2]
#coverWide$normal = ( coverWide[ , normalv] - mean( coverWide [ , normalv], na.rm = TRUE) )
coverWide$diff1 = coverWide[, diffv]
coverWide$diff2 = coverWide[, diffv2]
ggplot(coverWide, aes(x = logLstCover, y = logCover, group = UPlotID)) +
geom_point() + geom_abline( yintercept = 0, slope =1) +
geom_smooth(se = FALSE, method = 'lm')
m1 = lmer( logCover ~ logLstCover + normal2*diff2 + (1+logLstCover|UPlotID), data = coverWide )
m1 = lmer( logCover ~ logLstCover + normal1*diff1 + (1+logLstCover|UPlotID), data = coverWide )
3064/35
25*87.54
10541+10752
10541+10752+11331+11015
install.packages("deSolve")
lambda1 = c(0.99,1.01,1)
lambda2 = c(1.5,0.5,1.05)
mean(lambda1)
mean(lambda2)
mean(log(lambda1))
mean(log(lambda2))
lambda1 = c(0.99,1.01,1)
lambda2 = c(1.5,0.5,1.05)
mean(lambda1)
mean(lambda2)
exp(mean(log(lambda1)))
exp(mean(log(lambda2)))
?rpois
rpois(100,1.5)
a <- rpois(100,1.5)
hist(a)
abline(v=mean(a),color="red")
abline(v=mean(a),col="red")
a <- rpois(100,1.5,breaks=10)
hist(a)
abline(v=mean(a),col="red")
a <- rpois(100,1.5)
hist(a,breaks=10)
abline(v=mean(a),col="red")
myvar <- 10
mycovar <- -5
mu <- 100
vcov <- cbind(c(myvar,mycovar),c(mycovar,myvar))
vcov
out <- rmvnorm(100,mu,vcov)
library(mvtnorm)
out <- rmvnorm(100,mu,vcov)
myvar <- 10
mycovar <- -5
mu <- c(100,100)
vcov <- cbind(c(myvar,mycovar),c(mycovar,myvar))
out <- rmvnorm(100,mu,vcov)
plot(out)
head(out)
myvar <- 10
mycovar <- 5
mu <- c(100,100)
vcov <- cbind(c(myvar,mycovar),c(mycovar,myvar))
out <- rmvnorm(1000,mu,vcov)
plot(out)
vcov <- cbind(c(myvar,mycovar/2),c(mycovar,myvar))
vcov
out <- rmvnorm(1000,mu,vcov)
7.5*15
112.5-35
cbind(40:70, 40:70/70)
exp(0.98)
log(0.98)
75.63*25
75.63*35
75.63*30
75.63*42
75.63*40
17.5*15-25
25*15+65-50
14.5*15-10
115.5*15+100
15.5*15+100
0.25*170*2
4.8*80
totT <- 100
r <- 1.5
N <- matrix(0,totT,2)
N[1, ] <- c(1,1)
aij <- 0.001
a <- c(0.002,0.0019)
grow <- function(myN,a,aij){
newN <- numeric(2)
newN[1] <- myN[1] + r*myN[1]*(1-a[1]*myN[1] - aij*myN[2])
newN[2] <- myN[2] + r*myN[2]*(1-a[2]*myN[2] - aij*myN[1])
return(newN)
}
for(i in 1:(totT-1)){
N[i+1,] <- grow(N[i],a,aij)
}
plot(N)
N
head(N)
for(i in 1:(totT-1)){
N[i+1,] <- grow(N[i,],a,aij)
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
matplot(N)
14.5*15-30
13*15
360*0.31
15^2
7.5*15
install.packages("coda")
install.packages("rjags")
12*15
7.5*15
11.5*15
12*15
41000/12
47000/12
39*17-65
39*17-65-200
228+458+220
4*669
450/(51*4)
205*3.50
225*3.50
228+458+410
285*3.50
7,133.22/2
7133.22/2
518+487+500
17.50*23-140-75
37.5*17.50-275
2+2
plot(1:10)
plot(1:10,20:29)
r=0.5
K=100
totalTime=100
initialN=2
time=1:totalTime
N=numeric(totalTime)
r
K
totalTime
totalTime=500
totalTime
time
N
N[1] = initialN
N
N[2] = N[1] + r*N[1]*(1-N[1]/K)
N
N[1] = initialN
N[2] = N[1] + r*N[1]*(1-N[1]/K)
N[3] = N[2] + r*N[2]*(1-N[2]/K)
N[4] = N[3] + r*N[3]*(1-N[3]/K)
N
for(i in 2:totalTime){
print(i)
}
for(i in 2:10){
print(i)
}
for(i in 2:10){
N[i] = N[i-1] + r*N[i-1]*(1-N[i-1]/K)
}
N[1:10]
# logistic growth model
r=0.5
K=100
totalTime=500
initialN=2
time=1:totalTime
N=numeric(totalTime)
N[1] = initialN
for(i in 2:totalTime){
N[i] = N[i-1] + r*N[i-1]*(1-N[i-1]/K)
}
N
plot(time,N)
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
sum(c(1,2,10))
#Time vector
totalTime<-(100)
time<-seq(1,totalTime)
#Parameterize Species 1
r1<-1.01
N1<-rep(0,length(time))
N1[1]<-5
a11<-0.01
a12<-0.02
#Parameterize Species 2
r2<-1.05
N2<-rep(0,length(time))
N2[1]<-5
a21<-0.02
a22<-0.05
#Lotka-Volterra function for Species 1
lg1 <- function(r,N1,a11, a12, N2){
newN1 = N1+(r1*N1)*(1-(a11*N1)-(a12*N2))
return(newN1)
}
#Lotka-Volterra function for Species 2
lg2 <- function(r,N2,a21, a22, N1){
newN2 = N2+(r2*N2)*(1-(a21*N2)-(a22*N1))
return(newN1)
}
#Create a loop
for(i in 2:length(time)){
N1[i]=lg1(r,N1[i-1],a11,a12,N2)
}
13*17.5
19*17.5
12*17.5
13.75*17.50
241+30
A=2
B=1
C=A+B
print(C)
source('~/.active-rstudio-document')
A=rnorm(10,0,1)
Sys.getenv("PATH")
system('g++ -v')
system('where make')
cat('Sys.setenv(BINPREF = "C:/Rtools/mingw_$(WIN)/bin/")',
file = file.path(Sys.getenv("HOME"), ".Rprofile"),
sep = "\n", append = TRUE)
system('where make')
system('g++ -v')
Sys.getenv("PATH")
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies=TRUE)
1+1
A = rep(3,5)
A
sum(A)
?rep
rep(x=2.5,times=10)
rep(2.5,10)
rep(10,2.5)
rep(times=10,x=2.5)
N=()
N=numeric(100)
N
# inputs
r=0.2
K=10
totTime=100
initN = 2
# everything else
time_vector = 1:totTime
N=rep(NA,totTime)
N[1] = initN
N
N[2] = N[1] + r*N[1]*(1-N[1]/K)
N
N[3] = N[2] + r*N[2]*(1-N[2]/K)
N[3]
for(my_index in 2:totTime){
print(my_index)
}
for(my_index in 2:totTime){
N[my_index] = N[my_index-1] + r*N[my_index-1]*(1-N[my_index-1]/K)
}
N
plot(N,type='l')
setwd("c:/repos/forecasting-dynamics-course")
setwd("c:/repos/forecasting-dynamics-course")
library(forecast)
library(ggplot2)
data = read.csv("portal_timeseries.csv", stringsAsFactors = FALSE)
data = read.csv("data/portal_timeseries.csv", stringsAsFactors = FALSE)
head(data)
NDVI_ts = ts(data$NDVI, start = c(1992, 3), end = c(2014, 11), frequency = 12)
plot(NDVI_ts)
acf(NDVI_ts)
# HINDCAST
NDVI_train <- window(NDVI_ts, end = c(2011, 11))
NDVI_test <- window(NDVI_ts, start = c(2011, 12))
arima_model = auto.arima(NDVI_train, seasonal = FALSE)
arima_forecast = forecast(arima_model, h = 36)
# VISUALIZE
plot(arima_forecast)
lines(NDVI_test,col="red")
plot(arima_forecast$mean, NDVI_test)
plot(as.vector(arima_forecast$mean), as.vector(NDVI_test))
abline(0, 1)
# VISUALIZE
plot(arima_forecast)
lines(NDVI_test,col="red")
## model eval demos
setwd("c:/repos/forecasting-dynamics-course")
# SET UP
library(forecast)
library(ggplot2)
data = read.csv("data/portal_timeseries.csv", stringsAsFactors = FALSE)
head(data)
NDVI_ts = ts(data$NDVI, start = c(1992, 3), end = c(2014, 11), frequency = 12)
plot(NDVI_ts)
acf(NDVI_ts)
# HINDCAST
NDVI_train <- window(NDVI_ts, end = c(2011, 11))
NDVI_test <- window(NDVI_ts, start = c(2011, 12))
arima_model = auto.arima(NDVI_train, seasonal = FALSE)
arima_forecast = forecast(arima_model, h = 36)
arima_forecast
# VISUALIZE
plot(arima_forecast)
arima_model = auto.arima(NDVI_train) #, seasonal = FALSE)
arima_forecast = forecast(arima_model, h = 36)
# VISUALIZE
plot(arima_forecast)
# VISUALIZE
plot(arima_forecast)
lines(NDVI_test,col="red")
plot(arima_forecast$mean, NDVI_test)
plot(as.vector(arima_forecast$mean), as.vector(NDVI_test))
arima_forecast$mean
arima_model = auto.arima(NDVI_train , seasonal = FALSE)
arima_forecast = forecast(arima_model, h = 36)
# VISUALIZE
plot(arima_forecast)
lines(NDVI_test,col="red")
plot(arima_forecast$mean, NDVI_test)
plot(as.vector(arima_forecast$mean), as.vector(NDVI_test))
abline(0, 1)
# QUANTIFY
arima_accur = accuracy(arima_forecast, NDVI_test)
arima_accur
seasonal_arima_model = auto.arima(NDVI_train)
seasonal_arima_forecast = forecast(seasonal_arima_model, h = 36)
plot(seasonal_arima_forecast)
lines(NDVI_test)
plot(as.vector(seasonal_arima_forecast$mean), as.vector(NDVI_test))
abline(0, 1)
seasonal_accur <- accuracy(seasonal_arima_forecast, NDVI_test)
seasonal_accur
# COVERAGE
in_interval <- arima_forecast$lower[,1] < NDVI_test & arima_forecast$upper[,1] > NDVI_test
coverage <- sum(in_interval) / length(NDVI_test)
coverage
head(arima_forecast)
# COMPARE
data.frame(arima = arima_accur[2,], seasonal = seasonal_accur[2,])
in_interval_season <- seasonal_arima_forecast$lower[,1] < NDVI_test & seasonal_arima_forecast$upper[,1] > NDVI_test
coverage_season <- sum(in_interval_season) / length(NDVI_test)
coverage
coverage_season
# FORECAST HORIZON
plot(sqrt((arima_forecast$mean - NDVI_test)^2))
lines(sqrt((seasonal_arima_forecast$mean -  NDVI_test)^2), col = 'blue')
setwd("c:/repos/forecasting-dynamics-course")
library(forecast)
library(ggplot2)
data = read.csv("data/portal_timeseries.csv", stringsAsFactors = FALSE)
head(data)
NDVI_ts = ts(data$NDVI, start = c(1992, 3), end = c(2014, 11), frequency = 12)
plot(NDVI_ts)
acf(NDVI_ts)
# HINDCAST
NDVI_train <- window(NDVI_ts, end = c(2011, 11))
NDVI_test <- window(NDVI_ts, start = c(2011, 12))
arima_model = auto.arima(NDVI_train , seasonal = FALSE)
arima_forecast = forecast(arima_model, h = 36)
# VISUALIZE
plot(arima_forecast)
lines(NDVI_test,col="red")
plot(arima_forecast$mean, NDVI_test)
plot(as.vector(arima_forecast$mean), as.vector(NDVI_test))
abline(0, 1)
arima_model = auto.arima(NDVI_train , seasonal = TRUE)
arima_forecast = forecast(arima_model, h = 36)
# VISUALIZE
plot(arima_forecast)
lines(NDVI_test,col="red")
plot(as.vector(arima_forecast$mean), as.vector(NDVI_test))
abline(0, 1)
# QUANTIFY
arima_accur = accuracy(arima_forecast, NDVI_test)
arima_accur
arima_model = auto.arima(NDVI_train , seasonal = FALSE)
arima_forecast = forecast(arima_model, h = 36)
# VISUALIZE
plot(arima_forecast)
lines(NDVI_test,col="red")
plot(arima_forecast$mean, NDVI_test)
plot(as.vector(arima_forecast$mean), as.vector(NDVI_test))
abline(0, 1)
# QUANTIFY
arima_accur = accuracy(arima_forecast, NDVI_test)
arima_accur
# COVERAGE
in_interval <- arima_forecast$lower[,1] < NDVI_test & arima_forecast$upper[,1] > NDVI_test
coverage <- sum(in_interval) / length(NDVI_test)
coverage
# COMPARE
data.frame(arima = arima_accur[2,], seasonal = seasonal_accur[2,])
in_interval_season <- seasonal_arima_forecast$lower[,1] < NDVI_test & seasonal_arima_forecast$upper[,1] > NDVI_test
coverage_season <- sum(in_interval_season) / length(NDVI_test)
coverage
coverage_season
# FORECAST HORIZON
plot(sqrt((arima_forecast$mean - NDVI_test)^2))
lines(sqrt((seasonal_arima_forecast$mean -  NDVI_test)^2), col = 'blue')
